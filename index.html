<html>
<head>

</head>
<body>

<canvas id="canvas" width="480" height="480" style="border:1px solid #d3d3d3;">
Your browser does not support the HTML5 canvas tag.
</canvas>

<script>


function createShader(gl, type, source) {
    let shader = gl.createShader(type);
    if (shader) {
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            shader = null;
        }
    }
    return shader;
}


function createProgram(gl, vertexSource, fragmentSource) {
    let program = null;
    let vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);
    let fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);
    if (vertexShader && fragmentShader) {
        program = gl.createProgram();
        if (program) {
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                program = null;
            }
        }
    }
    gl.deleteShader(vertexShader);
    gl.deleteShader(fragmentShader);
    return program;
}


function createFloatTexture(gl, width, height) {
    let data = new Float32Array(width * height * 4);
    let texture = gl.createTexture();
    if (texture) {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(
            gl.TEXTURE_2D,
            0,
            gl.RGBA16F,
            width,
            height,
            0,
            gl.RGBA,
            gl.FLOAT,
            data
        );
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    }
    return texture;
}


function createFramebuffer(gl, texture) {
    let framebuffer = gl.createFramebuffer();
    if (framebuffer) {
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        let status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        if (status != gl.FRAMEBUFFER_COMPLETE) {
            console.error("Framebuffer not complete (" + status + ")");
            gl.deleteFramebuffer(framebuffer);
            framebuffer = null;
        }
        // TODO make sure to do gl.viewport(0, 0, width, height); when using custom buffer
    }
    return framebuffer;
}


// Context
var canvas = document.getElementById("canvas");
var gl = null;

// OpenGL objects
var pass1Program = null;
var renderProgram = null;
var vertexBuffer = null;
var vertexArray = null;
var textures = null;
var framebuffers = null;
var current = 0;


function initialize() {

    // Load WebGL 2 extensions
    if (!gl.getExtension("EXT_color_buffer_float"))
        console.error("EXT_color_buffer_float not available");
    //if (!gl.getExtension("OES_texture_float_linear"))
    //    console.error("OES_texture_float_linear not available");
    
    /*
     * First pass: advect and apply forces
     */
    pass1Program = createProgram(gl,
        `#version 300 es
        layout(location = 0) in vec2 pos;
        
        void main() {
            gl_Position = vec4(pos, 0.0, 1.0);
        }
        `,
        `#version 300 es
        precision highp float;
        
        uniform sampler2D u_texture;
        uniform vec2 u_resolution;
        
        out vec4 state;
        
        vec4 get(vec2 delta) {
            return texture(u_texture, (gl_FragCoord.xy + delta) / u_resolution);
        }
        
        void main() {
        
            // Fetch relevant values
            vec4 c = get(vec2( 0.0,  0.0));
            vec4 t = get(vec2( 0.0,  1.0));
            vec4 l = get(vec2(-1.0,  0.0));
            vec4 r = get(vec2( 1.0,  0.0));
            vec4 b = get(vec2( 0.0, -1.0));
            
            // Self-advection
            vec2 advection = get(-c.xy).xy;
            
            // Pressure effect
            float density = 1.0;
            vec2 pressure = -vec2(r.z - l.z, t.z - b.z) / (2.0 * density);
            
            // TODO viscosity? seems that numerical instability tend to dampen the fluid anyway
            
            // External forces
            // TODO forces
            vec2 force = vec2(0.0, 0.0);
            
            if (gl_FragCoord.x < 2.0 && gl_FragCoord.y < 2.0) {
                force = vec2(1.0, 0.2);
            }
            
            // Compute new (non divergence-free) velocity
            vec2 velocity = advection + pressure + force;
            
            // Pack
            state = vec4(velocity, c.zw);
        }
        `
    );
    
    /*
     * Second pass: apply a step of Jacobi method, to solve pressure equations
     */
    pass2Program = createProgram(gl,
        `#version 300 es
        layout(location = 0) in vec2 pos;
        
        void main() {
            gl_Position = vec4(pos, 0.0, 1.0);
        }
        `,
        `#version 300 es
        precision highp float;
        
        uniform sampler2D u_texture;
        uniform vec2 u_resolution;
        
        out vec4 state;
        
        vec4 get(vec2 delta) {
            return texture(u_texture, (gl_FragCoord.xy + delta) / u_resolution);
        }
        
        void main() {
        
            // Fetch relevant values
            vec4 c = get(vec2( 0.0,  0.0));
            vec4 t = get(vec2( 0.0,  1.0));
            vec4 l = get(vec2(-1.0,  0.0));
            vec4 r = get(vec2( 1.0,  0.0));
            vec4 b = get(vec2( 0.0, -1.0));
            
            // Estimate pressure
            float density = 1.0;
            float pressure = (r.z + l.z + t.z + b.z - (r.x - l.x + t.y - b.y) / 2.0) / 4.0;
            
            // Pack
            state = vec4(c.xy, pressure, c.w);
        }
        `
    );
    
    /*
     * Third pass: compute final velocity and advect dye
     */
    pass3Program = createProgram(gl,
        `#version 300 es
        layout(location = 0) in vec2 pos;
        
        void main() {
            gl_Position = vec4(pos, 0.0, 1.0);
        }
        `,
        `#version 300 es
        precision highp float;
        
        uniform sampler2D u_texture;
        uniform vec2 u_resolution;
        
        out vec4 state;
        
        vec4 get(vec2 delta) {
            return texture(u_texture, (gl_FragCoord.xy + delta) / u_resolution);
        }
        
        void main() {
        
            // Fetch relevant values
            vec4 c = get(vec2( 0.0,  0.0));
            vec4 t = get(vec2( 0.0,  1.0));
            vec4 l = get(vec2(-1.0,  0.0));
            vec4 r = get(vec2( 1.0,  0.0));
            vec4 b = get(vec2( 0.0, -1.0));
            
            // Compute divergence-free velocity.
            vec2 velocity = c.xy - 0.5 * vec2(r.z - l.z, t.z - b.z);
            
            // Advect dye
            float dye = get(-velocity).w;
            
            // Pack
            state = vec4(velocity, c.z, dye);
        }
        `
    );
    
    /*
     * Render pass: show ink
     */
    renderProgram = createProgram(gl,
        `#version 300 es
        layout(location = 0) in vec2 pos;
        
        void main() {
            gl_Position = vec4(pos, 0.0, 1.0);
        }
        `,
        `#version 300 es
        precision highp float;
        
        uniform sampler2D u_texture;
        uniform vec2 u_resolution;
        
        out vec4 color;
        
        vec4 get(vec2 delta) {
            return texture(u_texture, (gl_FragCoord.xy + delta) / u_resolution);
        }
        
        void main() {
            // TODO show ink instead
            color = vec4(get(vec2(0.0, 0.0)).xyz, 1.0);
        }
        `
    );
    
    // Create two sets of textures, and we will swap at each operation
    textures = [];
    framebuffers = []
    for (let i = 0; i < 2; ++i) {
        gl.activeTexture(gl.TEXTURE0 + i);
        let t = createFloatTexture(gl, gl.canvas.width, gl.canvas.height);
        let f = createFramebuffer(gl, t);
        textures.push(t);
        framebuffers.push(f);
    }
    
    // Create vertex buffer object with a single quad
    vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1.0, -1.0,
        1.0, -1.0,
        -1.0, 1.0,
        1.0, 1.0
    ]), gl.STATIC_DRAW);

    // Configure vertex array object
    vertexArray = gl.createVertexArray();
    gl.bindVertexArray(vertexArray);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
    
    // Start loop
    update();
}


function update() {
    const dt = 1000.0 / 60.0;

    // Clear
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    // Compute non-divergence-free velocity
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffers[current ^ 1]);
    gl.useProgram(pass1Program);
    gl.uniform1i(gl.getUniformLocation(pass1Program, "u_texture"), current);
    gl.uniform2f(gl.getUniformLocation(pass1Program, "u_resolution"), gl.canvas.width, gl.canvas.height);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    current ^= 1;

    // Apply a few optimization steps
    for (let i = 0; i < 5; ++i) {
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffers[current ^ 1]);
        gl.useProgram(pass2Program);
        gl.uniform1i(gl.getUniformLocation(pass2Program, "u_texture"), current);
        gl.uniform2f(gl.getUniformLocation(pass2Program, "u_resolution"), gl.canvas.width, gl.canvas.height);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        current ^= 1;
    }
    
    // Compute divergence-free velocity and advect dye
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffers[current ^ 1]);
    gl.useProgram(pass3Program);
    gl.uniform1i(gl.getUniformLocation(pass3Program, "u_texture"), current);
    gl.uniform2f(gl.getUniformLocation(pass3Program, "u_resolution"), gl.canvas.width, gl.canvas.height);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    current ^= 1;
    
    // Draw current state to the screen
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.useProgram(renderProgram);
    gl.uniform1i(gl.getUniformLocation(renderProgram, "u_texture"), current);
    gl.uniform2f(gl.getUniformLocation(renderProgram, "u_resolution"), gl.canvas.width, gl.canvas.height);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    // Schedule next step
    window.setTimeout(update, dt);
    // TODO maybe use window.requestAnimationFrame?
}


function main() {
    gl = canvas.getContext("webgl2");
    if (gl)
        initialize();
}


window.onload = main;

</script>

</body>
</html>
